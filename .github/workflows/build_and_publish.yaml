on:
  workflow_call:
    inputs:
      mode:
        required: true
        type: string

jobs:
  preflight:
    name: Preflight checks
    runs-on: ubuntu-latest
    outputs:
      repo_name: ${{ steps.info.outputs.repo_name }}
    steps:
      - name: Validate mode
        run: |
          if [ "${{ inputs.mode }}" != "dev" ] && [ "${{ inputs.mode }}" != "prod" ]; then
            echo "Invalid mode: ${{ inputs.mode }}"
            exit 1
          fi

      - name: Get repository name
        id: info
        env:
          REPOSITORY: ${{ github.repository }}
        run: echo "repo_name=${REPOSITORY#*/}" >> "$GITHUB_OUTPUT"

  validate:
    name: validate
    needs: [preflight]
    if: ${{ always() && needs.preflight.result == 'success' }}
    strategy:
      matrix:
        arch: [ x64-small, arm64 ]
    runs-on: github-hosted-ubuntu-${{ matrix.arch }}
    container:
      image: ghcr.io/grafana/grafana-build-tools:v0.24.0@sha256:309c71f542b53fcb5fbc9042ec45cbab881a3b310c3a57b843d8ffe979bfa951
      # --user is needed so that it's possible to access the git directory.
      # --group-add is needed so that it's possible to access the docker socket.
      #
      # ubuntu-latest and github-hosted-ubuntu-arm64 have different group ids for the docker socket.
      #
      # This works for GitHub runners
      options: --user 1001:118 --group-add 116
      # This works for self-hosted runners; 126 is the group for the docker socket.
      # options: --user 1000:126
      volumes:
        - /var/run/docker.sock:/var/run/docker.sock
        - /etc/passwd:/etc/passwd:ro
        - /etc/group:/etc/group:ro
    outputs:
      version: ${{ steps.version.outputs.value }}
    steps:
      - name: checkout
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Restore Go cache
        id: restore-go-cache
        uses: ./.github/actions/go-cache-restore

      - name: build info
        id: build-info
        run: |
          echo "os=$(go env GOOS)" >> "$GITHUB_OUTPUT"
          echo "arch=$(go env GOARCH)" >> "$GITHUB_OUTPUT"

      - name: ensure dependencies are up-to-date
        run: |
          make deps
          scripts/enforce-clean

      - name: version
        id: version
        run: |
          make version
          echo "value=$(cat dist/version)" >> "$GITHUB_OUTPUT"

      - name: build
        run: make build-native

      - name: lint
        run: make lint

      - name: test
        run: make test

      - name: test docker build
        uses: grafana/shared-workflows/actions/build-push-to-dockerhub@f0dd3480fa3e657d741dd9e8d9b999cfb61fc713
        with:
          push: false
          platforms: |-
            ${{ steps.build-info.outputs.os }}/${{ steps.build-info.outputs.arch }}
          tags: |-
            type=raw,value=${{ steps.version.outputs.value }}
            type=sha,prefix=sha-,format=short
            latest

      - name: create build artifacts
        run: |
          # Create a tarball of the build artifacts to preserve permissions and
          # the directory structure. The actions/upload-artifact action will
          # create a zip file, which cannot preserve all this information.
          tar -C dist -cf 'dist/build-artifacts-${{ steps.build-info.outputs.arch }}.tar' 'linux-${{ steps.build-info.outputs.arch }}'

      - name: upload build artifacts
        uses: actions/upload-artifact@50769540e7f4bd5e21e526ee35c689e35e0d6874 # v4
        with:
          name: build-artifacts-${{ steps.build-info.outputs.arch }}
          path: dist/build-artifacts-${{ steps.build-info.outputs.arch }}.tar
          retention-days: 1

      - name: Save Go cache
        id: save-go-cache
        uses: ./.github/actions/go-cache-save
        with:
          key: ${{ steps.restore-go-cache.outputs.key }}
          path: ${{ steps.restore-go-cache.outputs.path }}

  publish_images:
    name: publish images
    needs:
      - preflight
      - validate
    if: ${{ always() && needs.validate.result == 'success' && needs.preflight.result == 'success' }}
    runs-on: ubuntu-amd64
    outputs:
      image_name: ${{ steps.extract-image-metadata.outputs.image }}
      image_version: ${{ steps.extract-image-metadata.outputs.tag }}
    steps:
      - name: checkout
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
        with:
          fetch-depth: 0

      - name: download build artifacts
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4
        with:
          path: dist
          pattern: build-artifacts-*

      - name: extract build artifacts
        id: extract-build-artifacts
        # Note that the download-artifact action will create a directory for
        # each artifact that it downloads, named afer the artifact's name.
        # That's the `build-artifacts-*` portion of the path. The wildcard
        # refers to the architecture of the binaries. The artifact itself
        # consists of a single file, a tarball, and it's also named
        # `build-artifacts-*`. The tarball contains the linux-arch directory,
        # so everything is extracted directly to the dist directory.
        #
        # After extracting all the artifacts, this builds an output named
        # `platforms` that lists all the platforms that are available. This is
        # used by the step that builds the docker images to tell it what
        # platforms should be included.
        run: |
          find dist/build-artifacts-*/build-artifacts-*.tar -print0 | xargs -r0 -n1 -I{} tar -xvpf {} -C dist
          {
            echo 'platforms<<EOT'
            find dist/linux-* -maxdepth 0 -type d -print0 | xargs -r0 -n1 basename | tr - /
            echo 'EOT'
          } >> "$GITHUB_OUTPUT"

      - name: Get repository name
        env:
          REPOSITORY: ${{ github.repository }}
        id: info
        run: |
          case ${{ inputs.mode }} in
            dev)
              echo "tag=sha-${{ github.sha }}" >> "$GITHUB_OUTPUT"
              ;;
            prod)
              echo "tag=latest" >> "$GITHUB_OUTPUT"
              ;;
          esac

      - name: push container images to GAR
        id: push-to-gar
        uses: grafana/shared-workflows/actions/push-to-gar-docker@f0dd3480fa3e657d741dd9e8d9b999cfb61fc713
        with:
          environment: ${{ inputs.mode }}
          image_name: ${{ needs.preflight.outputs.repo_name }}
          push: true
          platforms: ${{ steps.extract-build-artifacts.outputs.platforms }}
          tags: |-
            type=raw,value=${{ needs.validate.outputs.version }}
            type=sha,prefix=sha-,format=short
            latest

      - name: extract image metadata
        id: extract-image-metadata
        run: |
          # Note that the variable DOCKER_METADATA_OUTPUT_BAKE_FILE_TAGS
          # already contains the name of the variables. It has the form
          # key=value\nkey=value\n...
          ./scripts/extract-image-info "${DOCKER_METADATA_OUTPUT_BAKE_FILE_TAGS}"
          ./scripts/extract-image-info "${DOCKER_METADATA_OUTPUT_BAKE_FILE_TAGS}" >> "$GITHUB_OUTPUT"

  release:
    name: release
    needs:
      - preflight
      - publish_images
    if: ${{ always() && needs.publish_images.result == 'success' && needs.preflight.result == 'success' }}
    runs-on: ubuntu-amd64
    steps:
      # The following two steps are needed because trigger-argo-workflow is
      # calling setup-go *after* setup-argo, and setup-argo actually needs go
      # to obtain GOOS and GOARCH (because it's downloading a remote tarball
      # where those values are part of the filename).
      - name: checkout
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@0a12ed9d6a96ab950c8f026ed9f722fe0da7ef32 # v5.0.2
        with:
          go-version-file: ./go.mod

    # Commented out until we know it's working.
    # - name: Trigger argo workflow
    #   uses: grafana/shared-workflows/actions/trigger-argo-workflow@f0dd3480fa3e657d741dd9e8d9b999cfb61fc713
    #   with:
    #     namespace: synthetic-monitoring-cd
    #     workflow_template: deploy-${{ needs.preflight.outputs.repo_name }}
    #     extra_args: "--generate-name deploy-${{ needs.preflight.outputs.repo_name }}-"
    #     parameters: |
    #       mode=${{ (inputs.mode == 'prod' && 'release') || (inputs.mode == 'dev' && 'dev') }}
    #       image=${{ needs.publish_images.outputs.image_name }}:${{ needs.publish_images.outputs.image_version }}
    #       image_name=${{ needs.publish_images.outputs.image_name }}
    #       image_version=${{ needs.publish_images.outputs.image_version }}
    #       dockertag=${{ needs.publish_images.outputs.image_version }}
    #       commit=${{ github.sha }}
    #       commit_author=${{ github.actor }}
    #       commit_link=${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}
