on:
  workflow_call:
    inputs:
      mode:
        required: true
        type: string

jobs:
  preflight:
    name: Preflight checks
    runs-on: ubuntu-latest
    outputs:
      repo_name: ${{ steps.info.outputs.repo_name }}
    steps:
      - name: Validate mode
        run: |
          if [ "${{ inputs.mode }}" != "dev" ] && [ "${{ inputs.mode }}" != "prod" ]; then
            echo "Invalid mode: ${{ inputs.mode }}"
            exit 1
          fi

      - name: Get repository name
        id: info
        env:
          REPOSITORY: ${{ github.repository }}
        run: echo "repo_name=${REPOSITORY#*/}" >> "$GITHUB_OUTPUT"

  validate:
    name: validate
    needs: [preflight]
    if: ${{ always() && needs.preflight.result == 'success' }}
    strategy:
      matrix:
        arch: [ x64-large, arm64 ]
    runs-on: github-hosted-ubuntu-${{ matrix.arch }}

    container:
      image: ghcr.io/grafana/grafana-build-tools:v0.24.0@sha256:309c71f542b53fcb5fbc9042ec45cbab881a3b310c3a57b843d8ffe979bfa951
    outputs:
      version: ${{ steps.version.outputs.value }}

    steps:
      - name: checkout
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Set up global git config
        run: |
          # The directory where the code has been checked out ends up belonging
          # to a different user, so git complains about permissions. Indicate
          # that it's safe to ignore.
          git config --global --add safe.directory '*'

      - name: Restore Go cache
        id: restore-go-cache
        uses: ./.github/actions/go-cache-restore

      - name: build info
        id: build-info
        run: |
          echo "os=$(go env GOOS)" >> "$GITHUB_OUTPUT"
          echo "arch=$(go env GOARCH)" >> "$GITHUB_OUTPUT"

      - name: ensure dependencies are up-to-date
        run: |
          make deps
          scripts/enforce-clean

      - name: version
        id: version
        run: |
          make version
          echo "value=$(cat dist/version)" >> "$GITHUB_OUTPUT"

      - name: build
        run: make build-native

#     - name: lint
#       run: make lint

#     - name: test
#       run: make test

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@c47758b77c9736f4b2ef4073d4d51994fabfe349 # v3.7.1

      - name: docker metadata (no brower)
        id: docker-metadata-no-browser
        uses: docker/metadata-action@8e5442c4ef9f78752691e2d8f8d19755c6f78e81 # v5.5.1
        with:
          images: ${{ needs.preflight.outputs.repo_name }}
          tags: |-
            type=raw,value=${{ steps.version.outputs.value }}
            type=sha,prefix=sha-,format=short
            latest

      - name: test docker build (no browser)
        uses: docker/build-push-action@4f58ea79222b3b9dc2c8bbdd6debcef730109a75 # v6.9.0
        with:
          context: .
          push: false
          tags: ${{ steps.docker-metadata-no-browser.outputs.tags }}
          labels: ${{ steps.docker-metadata-no-browser.outputs.labels }}
          target: release
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: docker metadata (brower)
        id: docker-metadata-browser
        uses: docker/metadata-action@8e5442c4ef9f78752691e2d8f8d19755c6f78e81 # v5.5.1
        with:
          images: ${{ needs.preflight.outputs.repo_name }}
          tags: |-
            type=raw,value=${{ steps.version.outputs.value }}-browser
            type=sha,prefix=sha-,suffix=-browser,format=short
            latest-browser

      - name: test docker build (browser)
        uses: grafana/shared-workflows/actions/build-push-to-dockerhub@f0dd3480fa3e657d741dd9e8d9b999cfb61fc713
        with:
          context: .
          push: false
          tags: ${{ steps.docker-metadata-browser.outputs.tags }}
          labels: ${{ steps.docker-metadata-browser.outputs.labels }}
          target: with-browser
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: list images
        run: |
          echo ==== docker images
          docker images
          echo ==== docker container ls
          docker container ls
          echo ==== docker ps -a
          docker ps -a

      - name: create build artifacts
        run: |
          # Create a tarball of the build artifacts to preserve permissions and
          # the directory structure. The actions/upload-artifact action will
          # create a zip file, which cannot preserve all this information.
          tar -C dist -cf 'dist/build-artifacts-bin-${{ steps.build-info.outputs.arch }}.tar' 'linux-${{ steps.build-info.outputs.arch }}'

          BASENAME="${{ needs.preflight.outputs.repo_name }}-linux-${{ steps.build-info.outputs.arch }}"

          # Create a tarball for the regular docker image.
          ./scripts/export-docker-image '${{ needs.preflight.outputs.repo_name }}:latest' 'dist/build-artifacts-image-${{ steps.build-info.outputs.arch }}.tar'

          # Create a tarball for the browser docker image.
          ./scripts/export-docker-image '${{ needs.preflight.outputs.repo_name }}:latest-browser' 'dist/build-artifacts-image-browser-${{ steps.build-info.outputs.arch }}.tar'

      - name: upload build artifacts
        uses: actions/upload-artifact@50769540e7f4bd5e21e526ee35c689e35e0d6874 # v4
        with:
          name: build-artifacts-${{ steps.build-info.outputs.arch }}
          path: dist/build-artifacts-*.tar
          retention-days: 1
          if-no-files-found: error
          overwrite: false

      - name: Save Go cache
        id: save-go-cache
        uses: ./.github/actions/go-cache-save
        with:
          key: ${{ steps.restore-go-cache.outputs.key }}
          path: ${{ steps.restore-go-cache.outputs.path }}

  publish_images:
    name: publish images
    needs:
      - preflight
      - validate
    if: ${{ always() && needs.validate.result == 'success' && needs.preflight.result == 'success' }}
    runs-on: ubuntu-amd64
    outputs:
      image_name: ${{ steps.extract-image-metadata.outputs.image }}
      image_version: ${{ steps.extract-image-metadata.outputs.tag }}
    steps:
      - name: checkout
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
        with:
          fetch-depth: 0

      - name: Set up global git config
        run: |
          # The directory where the code has been checked out ends up belonging
          # to a different user, so git complains about permissions. Indicate
          # that it's safe to ignore.
          git config --global --add safe.directory '*'

      - name: download build artifacts
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4
        with:
          path: dist
          pattern: build-artifacts-*

      - name: extract build artifacts
        id: extract-build-artifacts
        # Note that the download-artifact action will create a directory for
        # each artifact that it downloads, named afer the artifact's name.
        # That's the `build-artifacts-*` portion of the path.
        #
        # There are two sets of artifacts: binaries and images. The first one
        # is named build-artifacts-bin-*, the wildcard refers to the
        # architecture of the binaries. The artifact itself consists of a
        # single file, a tarball, and it's also named `build-artifacts-bin-*`.
        # The tarball contains the linux-arch directory, so everything is
        # extracted directly to the dist directory.
        #
        # For images, the artifact is named build-artifacts-image-*. This
        # contains a tarball with the docker image. Move it to the dist
        # directory to make things easier.
        #
        # After extracting all the artifacts, this builds an output named
        # `platforms` that lists all the platforms that are available. This is
        # used by the step that builds the docker images to tell it what
        # platforms should be included.
        run: |
          find dist/build-artifacts-*/build-artifacts-bin-*.tar -print0 | xargs -r0 -n1 -I{} tar -xvpf {} -C dist

          {
            echo 'platforms<<EOT'
            find dist/linux-* -maxdepth 0 -type d -print0 | xargs -r0 -n1 basename | tr - /
            echo 'EOT'
          } >> "$GITHUB_OUTPUT"

          mv dist/build-artifacts-image-*/build-artifacts-image-*.tar dist/

      - name: push container images to GAR (no browser)
        id: push-to-gar
        uses: grafana/shared-workflows/actions/push-to-gar-docker@f0dd3480fa3e657d741dd9e8d9b999cfb61fc713
        with:
          environment: ${{ inputs.mode }}
          image_name: ${{ needs.preflight.outputs.repo_name }}
          push: true
          platforms: ${{ steps.extract-build-artifacts.outputs.platforms }}
          tags: |-
            type=raw,value=${{ needs.validate.outputs.version }}
            type=sha,prefix=sha-,format=short
            latest
          file: Dockerfile.build
          target: release

      - name: push container images to GAR (browser)
        uses: grafana/shared-workflows/actions/push-to-gar-docker@f0dd3480fa3e657d741dd9e8d9b999cfb61fc713
        with:
          environment: ${{ inputs.mode }}
          image_name: ${{ needs.preflight.outputs.repo_name }}
          push: true
          platforms: ${{ steps.extract-build-artifacts.outputs.platforms }}
          tags: |-
            type=raw,value=${{ needs.validate.outputs.version }}-browser
            type=sha,prefix=sha-,suffix=-browser,format=short
            latest-browser
          file: Dockerfile.build
          target: with-browser

      - name: extract image metadata
        id: extract-image-metadata
        run: |
          # Note that the variable DOCKER_METADATA_OUTPUT_BAKE_FILE_TAGS
          # already contains the name of the variables. It has the form
          # key=value\nkey=value\n...
          ./scripts/extract-image-info "${DOCKER_METADATA_OUTPUT_BAKE_FILE_TAGS}"
          ./scripts/extract-image-info "${DOCKER_METADATA_OUTPUT_BAKE_FILE_TAGS}" >> "$GITHUB_OUTPUT"

  release:
    name: release
    needs:
      - preflight
      - publish_images
    if: ${{ always() && needs.publish_images.result == 'success' && needs.preflight.result == 'success' }}
    runs-on: ubuntu-amd64
    steps:
      # The following two steps are needed because trigger-argo-workflow is
      # calling setup-go *after* setup-argo, and setup-argo actually needs go
      # to obtain GOOS and GOARCH (because it's downloading a remote tarball
      # where those values are part of the filename).
      - name: checkout
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@0a12ed9d6a96ab950c8f026ed9f722fe0da7ef32 # v5.0.2
        with:
          go-version-file: ./go.mod

    # Commented out until we know it's working.
    # - name: Trigger argo workflow
    #   uses: grafana/shared-workflows/actions/trigger-argo-workflow@f0dd3480fa3e657d741dd9e8d9b999cfb61fc713
    #   with:
    #     namespace: synthetic-monitoring-cd
    #     workflow_template: deploy-${{ needs.preflight.outputs.repo_name }}
    #     extra_args: "--generate-name deploy-${{ needs.preflight.outputs.repo_name }}-"
    #     parameters: |
    #       mode=${{ (inputs.mode == 'prod' && 'release') || (inputs.mode == 'dev' && 'dev') }}
    #       image=${{ needs.publish_images.outputs.image_name }}:${{ needs.publish_images.outputs.image_version }}
    #       image_name=${{ needs.publish_images.outputs.image_name }}
    #       image_version=${{ needs.publish_images.outputs.image_version }}
    #       dockertag=${{ needs.publish_images.outputs.image_version }}
    #       commit=${{ github.sha }}
    #       commit_author=${{ github.actor }}
    #       commit_link=${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}
