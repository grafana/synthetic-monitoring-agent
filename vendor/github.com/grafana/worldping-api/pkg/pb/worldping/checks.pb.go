// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: checks.proto

package worldping

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type StatusCode int32

const (
	StatusCode_OK               StatusCode = 0
	StatusCode_NOT_FOUND        StatusCode = 1
	StatusCode_INVALID_ARGUMENT StatusCode = 2
	StatusCode_ALREADY_EXISTS   StatusCode = 3
	StatusCode_INTERNAL_ERROR   StatusCode = 4
	StatusCode_NOT_AUTHORIZED   StatusCode = 5
)

var StatusCode_name = map[int32]string{
	0: "OK",
	1: "NOT_FOUND",
	2: "INVALID_ARGUMENT",
	3: "ALREADY_EXISTS",
	4: "INTERNAL_ERROR",
	5: "NOT_AUTHORIZED",
}

var StatusCode_value = map[string]int32{
	"OK":               0,
	"NOT_FOUND":        1,
	"INVALID_ARGUMENT": 2,
	"ALREADY_EXISTS":   3,
	"INTERNAL_ERROR":   4,
	"NOT_AUTHORIZED":   5,
}

func (x StatusCode) String() string {
	return proto.EnumName(StatusCode_name, int32(x))
}

func (StatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{0}
}

type CheckOperation int32

const (
	CheckOperation_CHECK_ADD    CheckOperation = 0
	CheckOperation_CHECK_UPDATE CheckOperation = 1
	CheckOperation_CHECK_DELETE CheckOperation = 2
)

var CheckOperation_name = map[int32]string{
	0: "CHECK_ADD",
	1: "CHECK_UPDATE",
	2: "CHECK_DELETE",
}

var CheckOperation_value = map[string]int32{
	"CHECK_ADD":    0,
	"CHECK_UPDATE": 1,
	"CHECK_DELETE": 2,
}

func (x CheckOperation) String() string {
	return proto.EnumName(CheckOperation_name, int32(x))
}

func (CheckOperation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{1}
}

type HttpMethod int32

const (
	HttpMethod_GET     HttpMethod = 0
	HttpMethod_CONNECT HttpMethod = 1
	HttpMethod_DELETE  HttpMethod = 2
	HttpMethod_HEAD    HttpMethod = 3
	HttpMethod_OPTIONS HttpMethod = 4
	HttpMethod_POST    HttpMethod = 5
	HttpMethod_PUT     HttpMethod = 6
	HttpMethod_TRACE   HttpMethod = 7
)

var HttpMethod_name = map[int32]string{
	0: "GET",
	1: "CONNECT",
	2: "DELETE",
	3: "HEAD",
	4: "OPTIONS",
	5: "POST",
	6: "PUT",
	7: "TRACE",
}

var HttpMethod_value = map[string]int32{
	"GET":     0,
	"CONNECT": 1,
	"DELETE":  2,
	"HEAD":    3,
	"OPTIONS": 4,
	"POST":    5,
	"PUT":     6,
	"TRACE":   7,
}

func (x HttpMethod) String() string {
	return proto.EnumName(HttpMethod_name, int32(x))
}

func (HttpMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{2}
}

type DnsRecordType int32

const (
	DnsRecordType_ANY   DnsRecordType = 0
	DnsRecordType_A     DnsRecordType = 1
	DnsRecordType_AAAA  DnsRecordType = 2
	DnsRecordType_CNAME DnsRecordType = 3
	DnsRecordType_MX    DnsRecordType = 4
	DnsRecordType_NS    DnsRecordType = 5
	DnsRecordType_PTR   DnsRecordType = 6
	DnsRecordType_SOA   DnsRecordType = 7
	DnsRecordType_SRV   DnsRecordType = 8
	DnsRecordType_TXT   DnsRecordType = 9
)

var DnsRecordType_name = map[int32]string{
	0: "ANY",
	1: "A",
	2: "AAAA",
	3: "CNAME",
	4: "MX",
	5: "NS",
	6: "PTR",
	7: "SOA",
	8: "SRV",
	9: "TXT",
}

var DnsRecordType_value = map[string]int32{
	"ANY":   0,
	"A":     1,
	"AAAA":  2,
	"CNAME": 3,
	"MX":    4,
	"NS":    5,
	"PTR":   6,
	"SOA":   7,
	"SRV":   8,
	"TXT":   9,
}

func (x DnsRecordType) String() string {
	return proto.EnumName(DnsRecordType_name, int32(x))
}

func (DnsRecordType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{3}
}

type DnsProtocol int32

const (
	DnsProtocol_TCP DnsProtocol = 0
	DnsProtocol_UDP DnsProtocol = 1
)

var DnsProtocol_name = map[int32]string{
	0: "TCP",
	1: "UDP",
}

var DnsProtocol_value = map[string]int32{
	"TCP": 0,
	"UDP": 1,
}

func (x DnsProtocol) String() string {
	return proto.EnumName(DnsProtocol_name, int32(x))
}

func (DnsProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{4}
}

type IpVersion int32

const (
	IpVersion_Any IpVersion = 0
	IpVersion_V4  IpVersion = 1
	IpVersion_V6  IpVersion = 2
)

var IpVersion_name = map[int32]string{
	0: "Any",
	1: "V4",
	2: "V6",
}

var IpVersion_value = map[string]int32{
	"Any": 0,
	"V4":  1,
	"V6":  2,
}

func (x IpVersion) String() string {
	return proto.EnumName(IpVersion_name, int32(x))
}

func (IpVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{5}
}

// Void is an empty message used by RPC methods that don't take
// arguments.
type Void struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Void) Reset()         { *m = Void{} }
func (m *Void) String() string { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()    {}
func (*Void) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{0}
}
func (m *Void) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Void) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Void.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Void) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Void.Merge(m, src)
}
func (m *Void) XXX_Size() int {
	return m.Size()
}
func (m *Void) XXX_DiscardUnknown() {
	xxx_messageInfo_Void.DiscardUnknown(m)
}

var xxx_messageInfo_Void proto.InternalMessageInfo

type Status struct {
	Code                 StatusCode `protobuf:"varint,1,opt,name=code,proto3,enum=worldping.StatusCode" json:"code,omitempty"`
	Message              string     `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{1}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return m.Size()
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

type RegisterProbeResult struct {
	Probe                Probe    `protobuf:"bytes,1,opt,name=probe,proto3" json:"probe"`
	Status               Status   `protobuf:"bytes,2,opt,name=status,proto3" json:"status"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RegisterProbeResult) Reset()         { *m = RegisterProbeResult{} }
func (m *RegisterProbeResult) String() string { return proto.CompactTextString(m) }
func (*RegisterProbeResult) ProtoMessage()    {}
func (*RegisterProbeResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{2}
}
func (m *RegisterProbeResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterProbeResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterProbeResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterProbeResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterProbeResult.Merge(m, src)
}
func (m *RegisterProbeResult) XXX_Size() int {
	return m.Size()
}
func (m *RegisterProbeResult) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterProbeResult.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterProbeResult proto.InternalMessageInfo

// Probe represents a probe
type Probe struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	TenantId             int64    `protobuf:"varint,2,opt,name=tenantId,proto3" json:"tenantId"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name"`
	Latitude             float32  `protobuf:"fixed32,5,opt,name=latitude,proto3" json:"latitude"`
	Longitude            float32  `protobuf:"fixed32,6,opt,name=longitude,proto3" json:"longitude"`
	Labels               []Label  `protobuf:"bytes,8,rep,name=labels,proto3" json:"labels"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Probe) Reset()         { *m = Probe{} }
func (m *Probe) String() string { return proto.CompactTextString(m) }
func (*Probe) ProtoMessage()    {}
func (*Probe) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{3}
}
func (m *Probe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Probe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Probe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Probe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Probe.Merge(m, src)
}
func (m *Probe) XXX_Size() int {
	return m.Size()
}
func (m *Probe) XXX_DiscardUnknown() {
	xxx_messageInfo_Probe.DiscardUnknown(m)
}

var xxx_messageInfo_Probe proto.InternalMessageInfo

type TenantInfo struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TenantInfo) Reset()         { *m = TenantInfo{} }
func (m *TenantInfo) String() string { return proto.CompactTextString(m) }
func (*TenantInfo) ProtoMessage()    {}
func (*TenantInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{4}
}
func (m *TenantInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TenantInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TenantInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TenantInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TenantInfo.Merge(m, src)
}
func (m *TenantInfo) XXX_Size() int {
	return m.Size()
}
func (m *TenantInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TenantInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TenantInfo proto.InternalMessageInfo

// Tenant represents a user of worldping
type Tenant struct {
	Id                   int64       `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	OrgId                int64       `protobuf:"varint,2,opt,name=orgId,proto3" json:"orgId"`
	MetricsRemote        *RemoteInfo `protobuf:"bytes,3,opt,name=metricsRemote,proto3" json:"metricsRemote"`
	EventsRemote         *RemoteInfo `protobuf:"bytes,4,opt,name=eventsRemote,proto3" json:"eventsRemote"`
	Created              int64       `protobuf:"varint,100,opt,name=created,proto3" json:"created"`
	Modified             int64       `protobuf:"varint,101,opt,name=modified,proto3" json:"modified"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Tenant) Reset()         { *m = Tenant{} }
func (m *Tenant) String() string { return proto.CompactTextString(m) }
func (*Tenant) ProtoMessage()    {}
func (*Tenant) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{5}
}
func (m *Tenant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tenant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tenant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tenant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tenant.Merge(m, src)
}
func (m *Tenant) XXX_Size() int {
	return m.Size()
}
func (m *Tenant) XXX_DiscardUnknown() {
	xxx_messageInfo_Tenant.DiscardUnknown(m)
}

var xxx_messageInfo_Tenant proto.InternalMessageInfo

// RemoteInfo represents a target to send metrics or events to
type RemoteInfo struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name"`
	Url                  string   `protobuf:"bytes,2,opt,name=url,proto3" json:"url"`
	Username             string   `protobuf:"bytes,3,opt,name=username,proto3" json:"username"`
	Password             string   `protobuf:"bytes,4,opt,name=password,proto3" json:"password"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoteInfo) Reset()         { *m = RemoteInfo{} }
func (m *RemoteInfo) String() string { return proto.CompactTextString(m) }
func (*RemoteInfo) ProtoMessage()    {}
func (*RemoteInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{6}
}
func (m *RemoteInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteInfo.Merge(m, src)
}
func (m *RemoteInfo) XXX_Size() int {
	return m.Size()
}
func (m *RemoteInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteInfo proto.InternalMessageInfo

type CheckChange struct {
	Operation            CheckOperation `protobuf:"varint,1,opt,name=operation,proto3,enum=worldping.CheckOperation" json:"operation,omitempty"`
	Check                Check          `protobuf:"bytes,2,opt,name=check,proto3" json:"check"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CheckChange) Reset()         { *m = CheckChange{} }
func (m *CheckChange) String() string { return proto.CompactTextString(m) }
func (*CheckChange) ProtoMessage()    {}
func (*CheckChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{7}
}
func (m *CheckChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckChange.Merge(m, src)
}
func (m *CheckChange) XXX_Size() int {
	return m.Size()
}
func (m *CheckChange) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckChange.DiscardUnknown(m)
}

var xxx_messageInfo_CheckChange proto.InternalMessageInfo

type Label struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Label) Reset()         { *m = Label{} }
func (m *Label) String() string { return proto.CompactTextString(m) }
func (*Label) ProtoMessage()    {}
func (*Label) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{8}
}
func (m *Label) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Label) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Label.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Label) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Label.Merge(m, src)
}
func (m *Label) XXX_Size() int {
	return m.Size()
}
func (m *Label) XXX_DiscardUnknown() {
	xxx_messageInfo_Label.DiscardUnknown(m)
}

var xxx_messageInfo_Label proto.InternalMessageInfo

// Check represents a check.
//
// The "settings" field defines the type of check.
type Check struct {
	Id                   int64         `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	TenantId             int64         `protobuf:"varint,2,opt,name=tenantId,proto3" json:"tenantId"`
	Frequency            int64         `protobuf:"varint,3,opt,name=frequency,proto3" json:"frequency"`
	Offset               int64         `protobuf:"varint,4,opt,name=offset,proto3" json:"offset"`
	Timeout              int64         `protobuf:"varint,5,opt,name=timeout,proto3" json:"timeout"`
	Enabled              bool          `protobuf:"varint,6,opt,name=enabled,proto3" json:"enabled"`
	Labels               []Label       `protobuf:"bytes,7,rep,name=labels,proto3" json:"labels"`
	Settings             CheckSettings `protobuf:"bytes,8,opt,name=settings,proto3" json:"settings"`
	Probes               []int64       `protobuf:"varint,9,rep,packed,name=probes,proto3" json:"probes"`
	Created              int64         `protobuf:"varint,100,opt,name=created,proto3" json:"created"`
	Modified             int64         `protobuf:"varint,101,opt,name=modified,proto3" json:"modified"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Check) Reset()         { *m = Check{} }
func (m *Check) String() string { return proto.CompactTextString(m) }
func (*Check) ProtoMessage()    {}
func (*Check) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{9}
}
func (m *Check) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Check) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Check.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Check) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Check.Merge(m, src)
}
func (m *Check) XXX_Size() int {
	return m.Size()
}
func (m *Check) XXX_DiscardUnknown() {
	xxx_messageInfo_Check.DiscardUnknown(m)
}

var xxx_messageInfo_Check proto.InternalMessageInfo

// CheckSettings provides the settings for exactly one type of check.
type CheckSettings struct {
	Ping                 *PingSettings `protobuf:"bytes,1,opt,name=ping,proto3" json:"ping,omitempty"`
	Http                 *HttpSettings `protobuf:"bytes,2,opt,name=http,proto3" json:"http,omitempty"`
	Dns                  *DnsSettings  `protobuf:"bytes,3,opt,name=dns,proto3" json:"dns,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *CheckSettings) Reset()         { *m = CheckSettings{} }
func (m *CheckSettings) String() string { return proto.CompactTextString(m) }
func (*CheckSettings) ProtoMessage()    {}
func (*CheckSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{10}
}
func (m *CheckSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckSettings.Merge(m, src)
}
func (m *CheckSettings) XXX_Size() int {
	return m.Size()
}
func (m *CheckSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckSettings.DiscardUnknown(m)
}

var xxx_messageInfo_CheckSettings proto.InternalMessageInfo

// PingSettings provides the settings for a ping check.
//
// "hostname" is the hostname to check.
// "ipVersion" is the IP version to use in the IP layer.
type PingSettings struct {
	Hostname             string    `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname"`
	IpVersion            IpVersion `protobuf:"varint,2,opt,name=ipVersion,proto3,enum=worldping.IpVersion" json:"ipVersion"`
	SourceIpAddress      string    `protobuf:"bytes,3,opt,name=sourceIpAddress,proto3" json:"sourceIpAddress,omitempty"`
	PayloadSize          int64     `protobuf:"varint,4,opt,name=payloadSize,proto3" json:"payloadSize,omitempty"`
	DontFragment         bool      `protobuf:"varint,5,opt,name=dontFragment,proto3" json:"dontFragment"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *PingSettings) Reset()         { *m = PingSettings{} }
func (m *PingSettings) String() string { return proto.CompactTextString(m) }
func (*PingSettings) ProtoMessage()    {}
func (*PingSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{11}
}
func (m *PingSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PingSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PingSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PingSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PingSettings.Merge(m, src)
}
func (m *PingSettings) XXX_Size() int {
	return m.Size()
}
func (m *PingSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PingSettings.DiscardUnknown(m)
}

var xxx_messageInfo_PingSettings proto.InternalMessageInfo

// HttpSettings provides the settings for a HTTP check.
type HttpSettings struct {
	Url                          string        `protobuf:"bytes,1,opt,name=url,proto3" json:"url"`
	Method                       HttpMethod    `protobuf:"varint,2,opt,name=method,proto3,enum=worldping.HttpMethod" json:"method"`
	Headers                      []string      `protobuf:"bytes,3,rep,name=headers,proto3" json:"headers,omitempty"`
	Body                         string        `protobuf:"bytes,4,opt,name=body,proto3" json:"body,omitempty"`
	IpVersion                    IpVersion     `protobuf:"varint,5,opt,name=ipVersion,proto3,enum=worldping.IpVersion" json:"ipVersion"`
	NoFollowRedirects            bool          `protobuf:"varint,6,opt,name=noFollowRedirects,proto3" json:"noFollowRedirects"`
	FailIfSSL                    bool          `protobuf:"varint,7,opt,name=failIfSSL,proto3" json:"failIfSSL"`
	FailIfNotSSL                 bool          `protobuf:"varint,8,opt,name=failIfNotSSL,proto3" json:"failIfNotSSL"`
	ValidStatusCodes             []int32       `protobuf:"varint,9,rep,packed,name=validStatusCodes,proto3" json:"validStatusCodes,omitempty"`
	ValidHTTPVersions            []string      `protobuf:"bytes,10,rep,name=validHTTPVersions,proto3" json:"validHTTPVersions,omitempty"`
	FailIfBodyMatchesRegexp      []string      `protobuf:"bytes,11,rep,name=failIfBodyMatchesRegexp,proto3" json:"failIfBodyMatchesRegexp,omitempty"`
	FailIfBodyNotMatchesRegexp   []string      `protobuf:"bytes,12,rep,name=failIfBodyNotMatchesRegexp,proto3" json:"failIfBodyNotMatchesRegexp,omitempty"`
	FailIfHeaderMatchesRegexp    []HeaderMatch `protobuf:"bytes,13,rep,name=failIfHeaderMatchesRegexp,proto3" json:"failIfHeaderMatchesRegexp,omitempty"`
	FailIfHeaderNotMatchesRegexp []HeaderMatch `protobuf:"bytes,14,rep,name=failIfHeaderNotMatchesRegexp,proto3" json:"failIfHeaderNotMatchesRegexp,omitempty"`
	XXX_NoUnkeyedLiteral         struct{}      `json:"-"`
	XXX_unrecognized             []byte        `json:"-"`
	XXX_sizecache                int32         `json:"-"`
}

func (m *HttpSettings) Reset()         { *m = HttpSettings{} }
func (m *HttpSettings) String() string { return proto.CompactTextString(m) }
func (*HttpSettings) ProtoMessage()    {}
func (*HttpSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{12}
}
func (m *HttpSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpSettings.Merge(m, src)
}
func (m *HttpSettings) XXX_Size() int {
	return m.Size()
}
func (m *HttpSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpSettings.DiscardUnknown(m)
}

var xxx_messageInfo_HttpSettings proto.InternalMessageInfo

type HeaderMatch struct {
	Header               string   `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Regexp               string   `protobuf:"bytes,2,opt,name=regexp,proto3" json:"regexp,omitempty"`
	AllowMissing         bool     `protobuf:"varint,3,opt,name=allowMissing,proto3" json:"allowMissing,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeaderMatch) Reset()         { *m = HeaderMatch{} }
func (m *HeaderMatch) String() string { return proto.CompactTextString(m) }
func (*HeaderMatch) ProtoMessage()    {}
func (*HeaderMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{13}
}
func (m *HeaderMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeaderMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeaderMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderMatch.Merge(m, src)
}
func (m *HeaderMatch) XXX_Size() int {
	return m.Size()
}
func (m *HeaderMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderMatch.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderMatch proto.InternalMessageInfo

type DNSRRValidator struct {
	FailIfMatchesRegexp    []string `protobuf:"bytes,1,rep,name=failIfMatchesRegexp,proto3" json:"failIfMatchesRegexp,omitempty"`
	FailIfNotMatchesRegexp []string `protobuf:"bytes,2,rep,name=failIfNotMatchesRegexp,proto3" json:"failIfNotMatchesRegexp,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *DNSRRValidator) Reset()         { *m = DNSRRValidator{} }
func (m *DNSRRValidator) String() string { return proto.CompactTextString(m) }
func (*DNSRRValidator) ProtoMessage()    {}
func (*DNSRRValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{14}
}
func (m *DNSRRValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNSRRValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DNSRRValidator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DNSRRValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSRRValidator.Merge(m, src)
}
func (m *DNSRRValidator) XXX_Size() int {
	return m.Size()
}
func (m *DNSRRValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSRRValidator.DiscardUnknown(m)
}

var xxx_messageInfo_DNSRRValidator proto.InternalMessageInfo

// DnsSettings provides the settings for a DNS check.
//
// The way blackbox-exporter works, a DNS check tests a _server_, so the
// _target_ of the check is a server address, and the check itself
// contains the record to check.
type DnsSettings struct {
	Name                 string          `protobuf:"bytes,1,opt,name=name,proto3" json:"name"`
	Server               string          `protobuf:"bytes,2,opt,name=server,proto3" json:"server"`
	Port                 int32           `protobuf:"varint,3,opt,name=port,proto3" json:"port"`
	RecordType           DnsRecordType   `protobuf:"varint,4,opt,name=recordType,proto3,enum=worldping.DnsRecordType" json:"recordType"`
	Protocol             DnsProtocol     `protobuf:"varint,5,opt,name=protocol,proto3,enum=worldping.DnsProtocol" json:"protocol"`
	IpVersion            IpVersion       `protobuf:"varint,6,opt,name=ipVersion,proto3,enum=worldping.IpVersion" json:"ipVersion"`
	SourceIpAddress      string          `protobuf:"bytes,7,opt,name=sourceIpAddress,proto3" json:"sourceIpAddress,omitempty"`
	ValidRCodes          []string        `protobuf:"bytes,8,rep,name=validRCodes,proto3" json:"validRCodes,omitempty"`
	ValidateAnswer       *DNSRRValidator `protobuf:"bytes,9,opt,name=validateAnswer,proto3" json:"validateAnswerRRS,omitempty"`
	ValidateAuthority    *DNSRRValidator `protobuf:"bytes,10,opt,name=validateAuthority,proto3" json:"validateAuthorityRRS,omitempty"`
	ValidateAdditional   *DNSRRValidator `protobuf:"bytes,11,opt,name=validateAdditional,proto3" json:"validateAditionalRRS,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *DnsSettings) Reset()         { *m = DnsSettings{} }
func (m *DnsSettings) String() string { return proto.CompactTextString(m) }
func (*DnsSettings) ProtoMessage()    {}
func (*DnsSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{15}
}
func (m *DnsSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DnsSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DnsSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DnsSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DnsSettings.Merge(m, src)
}
func (m *DnsSettings) XXX_Size() int {
	return m.Size()
}
func (m *DnsSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_DnsSettings.DiscardUnknown(m)
}

var xxx_messageInfo_DnsSettings proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("worldping.StatusCode", StatusCode_name, StatusCode_value)
	proto.RegisterEnum("worldping.CheckOperation", CheckOperation_name, CheckOperation_value)
	proto.RegisterEnum("worldping.HttpMethod", HttpMethod_name, HttpMethod_value)
	proto.RegisterEnum("worldping.DnsRecordType", DnsRecordType_name, DnsRecordType_value)
	proto.RegisterEnum("worldping.DnsProtocol", DnsProtocol_name, DnsProtocol_value)
	proto.RegisterEnum("worldping.IpVersion", IpVersion_name, IpVersion_value)
	proto.RegisterType((*Void)(nil), "worldping.Void")
	proto.RegisterType((*Status)(nil), "worldping.Status")
	proto.RegisterType((*RegisterProbeResult)(nil), "worldping.RegisterProbeResult")
	proto.RegisterType((*Probe)(nil), "worldping.Probe")
	proto.RegisterType((*TenantInfo)(nil), "worldping.TenantInfo")
	proto.RegisterType((*Tenant)(nil), "worldping.Tenant")
	proto.RegisterType((*RemoteInfo)(nil), "worldping.RemoteInfo")
	proto.RegisterType((*CheckChange)(nil), "worldping.CheckChange")
	proto.RegisterType((*Label)(nil), "worldping.Label")
	proto.RegisterType((*Check)(nil), "worldping.Check")
	proto.RegisterType((*CheckSettings)(nil), "worldping.CheckSettings")
	proto.RegisterType((*PingSettings)(nil), "worldping.PingSettings")
	proto.RegisterType((*HttpSettings)(nil), "worldping.HttpSettings")
	proto.RegisterType((*HeaderMatch)(nil), "worldping.HeaderMatch")
	proto.RegisterType((*DNSRRValidator)(nil), "worldping.DNSRRValidator")
	proto.RegisterType((*DnsSettings)(nil), "worldping.DnsSettings")
}

func init() { proto.RegisterFile("checks.proto", fileDescriptor_a921b63774164c1f) }

var fileDescriptor_a921b63774164c1f = []byte{
	// 1958 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4f, 0x6f, 0xdb, 0xc8,
	0x15, 0x17, 0xf5, 0x5f, 0x4f, 0xb6, 0x96, 0x9e, 0x4d, 0xb2, 0x8a, 0x77, 0xd7, 0xf4, 0xb2, 0xd9,
	0x85, 0xeb, 0x04, 0x49, 0x91, 0x2e, 0xda, 0x6e, 0x17, 0x68, 0x4b, 0xfd, 0x49, 0xec, 0xc6, 0x96,
	0x8c, 0x91, 0x6c, 0x64, 0x17, 0x05, 0x0c, 0x5a, 0x1c, 0x4b, 0xc4, 0x4a, 0xa4, 0x4a, 0x8e, 0x92,
	0xba, 0xb7, 0xf6, 0x52, 0xa0, 0xdf, 0xa0, 0xa7, 0xf6, 0xda, 0x53, 0x8f, 0xfd, 0x00, 0xbd, 0xe4,
	0xd8, 0x43, 0xcf, 0x6c, 0x9b, 0x23, 0x3f, 0x41, 0x8f, 0xc5, 0xfc, 0x21, 0x35, 0x94, 0xec, 0x04,
	0xbb, 0xc8, 0x45, 0x7c, 0xf3, 0x9b, 0xdf, 0xfc, 0x66, 0xe6, 0xcd, 0x7b, 0x6f, 0x28, 0xc2, 0xc6,
	0x68, 0x42, 0x46, 0xdf, 0x84, 0x0f, 0xe7, 0x81, 0x4f, 0x7d, 0x54, 0x7b, 0xe9, 0x07, 0x53, 0x67,
	0xee, 0x7a, 0xe3, 0xed, 0x5b, 0x63, 0x7f, 0xec, 0x73, 0xf4, 0x11, 0xb3, 0x04, 0xc1, 0x2c, 0x43,
	0xf1, 0xcc, 0x77, 0x1d, 0xf3, 0x18, 0xca, 0x03, 0x6a, 0xd3, 0x45, 0x88, 0xbe, 0x0f, 0xc5, 0x91,
	0xef, 0x90, 0xa6, 0xb6, 0xab, 0xed, 0x35, 0x1e, 0xdf, 0x7e, 0x98, 0x2a, 0x3c, 0x14, 0x84, 0xb6,
	0xef, 0x10, 0xcc, 0x29, 0xa8, 0x09, 0x95, 0x19, 0x09, 0x43, 0x7b, 0x4c, 0x9a, 0xf9, 0x5d, 0x6d,
	0xaf, 0x86, 0x93, 0xa6, 0x49, 0xe1, 0x7d, 0x4c, 0xc6, 0x6e, 0x48, 0x49, 0x70, 0x12, 0xf8, 0x17,
	0x04, 0x93, 0x70, 0x31, 0xa5, 0xe8, 0x01, 0x94, 0xe6, 0xac, 0xc9, 0xc5, 0xeb, 0x8f, 0x75, 0x45,
	0x9c, 0xd3, 0x5a, 0xc5, 0x57, 0x91, 0x91, 0xc3, 0x82, 0x84, 0x1e, 0x41, 0x39, 0xe4, 0x53, 0x72,
	0xf5, 0xfa, 0xe3, 0xad, 0xb5, 0xb5, 0x48, 0xbe, 0xa4, 0x99, 0xff, 0xd3, 0xa0, 0xc4, 0x75, 0xd0,
	0x1d, 0xc8, 0xbb, 0x0e, 0x9f, 0xa5, 0xd0, 0x2a, 0xc7, 0x91, 0x91, 0x77, 0x1d, 0x9c, 0x77, 0x1d,
	0xb4, 0x07, 0x55, 0x4a, 0x3c, 0xdb, 0xa3, 0x87, 0x0e, 0x17, 0x2d, 0xb4, 0x36, 0xe2, 0xc8, 0x48,
	0x31, 0x9c, 0x5a, 0xe8, 0x23, 0x28, 0x7a, 0xf6, 0x8c, 0x34, 0x0b, 0x6c, 0x63, 0xad, 0x6a, 0x1c,
	0x19, 0xbc, 0x8d, 0xf9, 0x2f, 0xd3, 0x99, 0xda, 0xd4, 0xa5, 0x0b, 0x87, 0x34, 0x4b, 0xbb, 0xda,
	0x5e, 0x5e, 0xe8, 0x24, 0x18, 0x4e, 0x2d, 0x74, 0x1f, 0x6a, 0x53, 0xdf, 0x1b, 0x0b, 0x6a, 0x99,
	0x53, 0x37, 0xe3, 0xc8, 0x58, 0x82, 0x78, 0x69, 0xa2, 0x9f, 0x40, 0x79, 0x6a, 0x5f, 0x90, 0x69,
	0xd8, 0xac, 0xee, 0x16, 0x56, 0x1c, 0x74, 0xc4, 0x3a, 0x5a, 0x0d, 0xb6, 0xe1, 0x38, 0x32, 0x24,
	0x0f, 0xcb, 0xa7, 0xf9, 0x11, 0xc0, 0x50, 0x2c, 0xdd, 0xbb, 0xf4, 0x51, 0x63, 0xb9, 0x7d, 0xb6,
	0x6d, 0xf3, 0x6f, 0x79, 0x28, 0x8b, 0xee, 0x1b, 0x3d, 0x63, 0x40, 0xc9, 0x0f, 0xc6, 0xa9, 0x5b,
	0x6a, 0x71, 0x64, 0x08, 0x00, 0x8b, 0x07, 0xea, 0xc1, 0xe6, 0x8c, 0xd0, 0xc0, 0x1d, 0x85, 0x98,
	0xcc, 0x7c, 0x2a, 0x3c, 0x53, 0xcf, 0x04, 0x88, 0xe8, 0x60, 0x2b, 0x68, 0x6d, 0xc5, 0x91, 0x91,
	0xe5, 0xe3, 0x6c, 0x13, 0x3d, 0x83, 0x0d, 0xf2, 0x82, 0x78, 0x34, 0x91, 0x2b, 0xbe, 0x49, 0x4e,
	0x8f, 0x23, 0x23, 0x43, 0xc7, 0x99, 0x16, 0xfa, 0x14, 0x2a, 0xa3, 0x80, 0xd8, 0x94, 0x38, 0x4d,
	0x87, 0xaf, 0xbf, 0x1e, 0x47, 0x46, 0x02, 0xe1, 0xc4, 0x60, 0xc7, 0x36, 0xf3, 0x1d, 0xf7, 0xd2,
	0x25, 0x4e, 0x93, 0x2c, 0x8f, 0x3f, 0xc1, 0x70, 0x6a, 0x99, 0x7f, 0xd2, 0x00, 0x96, 0xf3, 0xa7,
	0xd1, 0xa0, 0x5d, 0x1b, 0x0d, 0x77, 0xa1, 0xb0, 0x08, 0xa6, 0x22, 0x07, 0x5a, 0x95, 0x38, 0x32,
	0x58, 0x13, 0xb3, 0x1f, 0x36, 0xe3, 0x22, 0x24, 0x81, 0x12, 0x4a, 0x7c, 0xc6, 0x04, 0xc3, 0xa9,
	0xc5, 0x98, 0x73, 0x3b, 0x0c, 0x5f, 0xfa, 0x81, 0xc3, 0x7d, 0x21, 0x99, 0x09, 0x86, 0x53, 0xcb,
	0xa4, 0x50, 0x6f, 0xb3, 0x24, 0x6f, 0x4f, 0x6c, 0x6f, 0x4c, 0xd0, 0x8f, 0xa1, 0xe6, 0xcf, 0x49,
	0x60, 0x53, 0xd7, 0xf7, 0x64, 0xd6, 0xde, 0x55, 0xbc, 0xc8, 0xa9, 0xfd, 0x84, 0x80, 0x97, 0x5c,
	0x96, 0x8d, 0xbc, 0x58, 0xc8, 0xf4, 0xd2, 0x57, 0x07, 0x25, 0xd9, 0xc8, 0x49, 0xe6, 0x13, 0x28,
	0xf1, 0x10, 0x7c, 0x8b, 0x2f, 0x0c, 0x28, 0xbd, 0xb0, 0xa7, 0x0b, 0x59, 0x11, 0x44, 0x1c, 0x71,
	0x00, 0x8b, 0x87, 0xf9, 0xef, 0x02, 0x94, 0xb8, 0xfc, 0x3b, 0x48, 0xd2, 0xfb, 0x50, 0xbb, 0x0c,
	0xc8, 0xaf, 0x17, 0xc4, 0x1b, 0x5d, 0x71, 0xf7, 0x16, 0x44, 0x72, 0xa5, 0x20, 0x5e, 0x9a, 0xc8,
	0x84, 0xb2, 0x7f, 0x79, 0x19, 0x12, 0xca, 0xdd, 0x5b, 0x68, 0x01, 0x4b, 0x23, 0x81, 0x60, 0xf9,
	0x64, 0x71, 0x44, 0xdd, 0x19, 0xf1, 0x17, 0x94, 0xa7, 0xb5, 0x8c, 0x23, 0x09, 0xe1, 0xc4, 0x60,
	0x34, 0xe2, 0xd9, 0x17, 0x53, 0xe2, 0xf0, 0x94, 0xae, 0x0a, 0x9a, 0x84, 0x70, 0x62, 0x28, 0xe9,
	0x5c, 0xf9, 0x76, 0xe9, 0x8c, 0x9e, 0x40, 0x35, 0x24, 0x94, 0xba, 0xde, 0x98, 0x95, 0x02, 0x76,
	0x3a, 0xcd, 0xd5, 0xd3, 0x19, 0xc8, 0xfe, 0x96, 0x2e, 0x35, 0xd2, 0x11, 0x38, 0xb5, 0xd8, 0x9e,
	0x79, 0x2d, 0x0d, 0x9b, 0xb5, 0xdd, 0x42, 0xb2, 0x67, 0x81, 0x60, 0xf9, 0x7c, 0xf7, 0xb9, 0xf3,
	0x2f, 0x0d, 0x36, 0x33, 0x4b, 0x44, 0x3f, 0x87, 0x22, 0x5b, 0xb8, 0x2c, 0xfb, 0x1f, 0xa8, 0x65,
	0xdf, 0xf5, 0xc6, 0xe9, 0x4e, 0x50, 0x1c, 0x19, 0x0d, 0x06, 0x3f, 0xf0, 0x67, 0x2e, 0x25, 0xb3,
	0x39, 0xbd, 0xc2, 0x7c, 0x20, 0x13, 0x98, 0x50, 0x3a, 0x97, 0x91, 0xaa, 0x0a, 0x1c, 0x50, 0x3a,
	0xcf, 0x0a, 0x30, 0xa2, 0x2a, 0xc0, 0xda, 0xe8, 0x4b, 0x28, 0x38, 0x5e, 0x28, 0x6b, 0xd6, 0x1d,
	0x65, 0x7c, 0xc7, 0x0b, 0xd3, 0xe1, 0xbc, 0x68, 0x39, 0x5e, 0xa8, 0x8c, 0x66, 0xa3, 0x7e, 0x5a,
	0x7c, 0xf5, 0x17, 0x43, 0x33, 0xff, 0x9e, 0x87, 0x0d, 0x75, 0xb9, 0xcc, 0x23, 0x13, 0x3f, 0xa4,
	0x4a, 0x32, 0x70, 0x8f, 0x24, 0x18, 0x4e, 0x2d, 0x64, 0x41, 0xcd, 0x9d, 0x9f, 0x91, 0x20, 0x64,
	0x29, 0x9a, 0xe7, 0x29, 0x7a, 0x4b, 0x59, 0xc3, 0x61, 0xd2, 0x27, 0xa2, 0x37, 0xa5, 0xe2, 0xa5,
	0x89, 0x9e, 0xc2, 0x7b, 0xa1, 0xbf, 0x08, 0x46, 0xe4, 0x70, 0x6e, 0x39, 0x4e, 0x40, 0xc2, 0x50,
	0xd6, 0x93, 0x8f, 0xe3, 0xc8, 0xb8, 0xbb, 0xd2, 0xa5, 0x6c, 0x60, 0x75, 0x14, 0xfa, 0x12, 0xea,
	0x73, 0xfb, 0x6a, 0xea, 0xdb, 0xce, 0xc0, 0xfd, 0x2d, 0x91, 0xb9, 0x70, 0x37, 0x8e, 0x8c, 0xdb,
	0x0a, 0xac, 0x08, 0xa8, 0x6c, 0xf4, 0x39, 0x6c, 0x38, 0xbe, 0x47, 0x9f, 0x04, 0xf6, 0x78, 0x46,
	0x3c, 0x91, 0x24, 0x55, 0x51, 0x9d, 0x55, 0x1c, 0x67, 0x5a, 0xe6, 0x9f, 0xab, 0xb0, 0xa1, 0x9e,
	0x53, 0x52, 0x30, 0xb5, 0x6b, 0x0a, 0xe6, 0x17, 0x50, 0x9e, 0x11, 0x3a, 0xf1, 0x1d, 0xe9, 0xa7,
	0xdb, 0x2b, 0x67, 0x7d, 0xcc, 0x3b, 0x45, 0x20, 0x0b, 0x22, 0x96, 0x4f, 0xf4, 0x08, 0x2a, 0x13,
	0x62, 0x3b, 0x24, 0x60, 0xae, 0x29, 0xec, 0xd5, 0x5a, 0xb7, 0xe3, 0xc8, 0xd8, 0x92, 0x90, 0xb2,
	0xa3, 0x84, 0x85, 0x3e, 0x83, 0xe2, 0x85, 0xef, 0x5c, 0xc9, 0x72, 0xcb, 0x83, 0x87, 0xb5, 0xd5,
	0xe0, 0x61, 0xed, 0xec, 0xf1, 0x95, 0xbe, 0xd3, 0xf1, 0xb5, 0x61, 0xcb, 0xf3, 0x9f, 0xf8, 0xd3,
	0xa9, 0xff, 0x12, 0x13, 0xc7, 0x0d, 0xc8, 0x88, 0x86, 0xb2, 0x76, 0xf0, 0x55, 0xae, 0x75, 0xe2,
	0x75, 0x88, 0x97, 0x3b, 0xdb, 0x9d, 0x1e, 0x5e, 0x0e, 0x06, 0x47, 0xcd, 0x0a, 0x1f, 0x2c, 0xca,
	0x5d, 0x02, 0xe2, 0xa5, 0xc9, 0x8e, 0x4a, 0x34, 0x7a, 0x3e, 0x65, 0xfc, 0xea, 0xf2, 0xa8, 0x54,
	0x1c, 0x67, 0x5a, 0xe8, 0x97, 0xa0, 0xbf, 0xb0, 0xa7, 0xae, 0xb3, 0x7c, 0xd7, 0x13, 0xa5, 0xa3,
	0xd4, 0xda, 0x89, 0x23, 0x63, 0x7b, 0xb5, 0x4f, 0x71, 0xd5, 0xda, 0x38, 0x74, 0x0c, 0x5b, 0x1c,
	0x3b, 0x18, 0x0e, 0x4f, 0xa4, 0x1f, 0xc2, 0x26, 0xf0, 0x93, 0x31, 0xe2, 0xc8, 0xf8, 0x70, 0xad,
	0x53, 0x51, 0x5b, 0x1f, 0x89, 0xce, 0xe1, 0x03, 0xb1, 0xd4, 0x96, 0xef, 0x5c, 0x1d, 0xdb, 0x74,
	0x34, 0x21, 0x21, 0x26, 0x63, 0xf2, 0x9b, 0x79, 0xb3, 0xce, 0x45, 0x3f, 0x8d, 0x23, 0xe3, 0x93,
	0x1b, 0x28, 0x8a, 0xf4, 0x4d, 0x2a, 0x68, 0x02, 0xdb, 0xcb, 0xae, 0x9e, 0x4f, 0xb3, 0x73, 0x6c,
	0xf0, 0x39, 0xf6, 0xe2, 0xc8, 0xb8, 0x77, 0x33, 0x4b, 0x99, 0xe6, 0x0d, 0x5a, 0xe8, 0x77, 0x1a,
	0xdc, 0x15, 0xdd, 0x07, 0x3c, 0x14, 0xb3, 0x33, 0x6d, 0xf2, 0xcb, 0x42, 0x2d, 0x52, 0x0a, 0xab,
	0x75, 0x5f, 0x96, 0xfb, 0xef, 0xdd, 0x28, 0xa0, 0x2c, 0xe2, 0xe6, 0x59, 0xd0, 0x1f, 0x35, 0xf8,
	0x48, 0xed, 0x5d, 0xdb, 0x70, 0xe3, 0x8d, 0xcb, 0x78, 0x28, 0x97, 0xf1, 0xd9, 0x9b, 0x34, 0x94,
	0x95, 0xbc, 0x71, 0x2e, 0xf3, 0xaf, 0x1a, 0xd4, 0x15, 0x75, 0xf4, 0x00, 0xca, 0x22, 0x49, 0x65,
	0x8d, 0xb8, 0x15, 0x47, 0x86, 0x2e, 0x10, 0x45, 0x53, 0x72, 0x18, 0x3b, 0x10, 0x6b, 0xce, 0x2f,
	0xd9, 0xc1, 0xea, 0x0a, 0x24, 0x07, 0xfd, 0x0c, 0x36, 0x6c, 0x96, 0x57, 0xc7, 0x6e, 0x18, 0xb2,
	0x4b, 0xa9, 0xc0, 0x13, 0x63, 0x3b, 0x8e, 0x8c, 0x3b, 0x2a, 0xae, 0x8c, 0xcc, 0xf0, 0xcd, 0x7f,
	0x68, 0xd0, 0xe8, 0xf4, 0x06, 0x18, 0x9f, 0xb1, 0x10, 0xb5, 0xa9, 0x1f, 0xa0, 0x01, 0xbc, 0x2f,
	0xb6, 0x97, 0xf5, 0xa0, 0xc6, 0x43, 0xe6, 0x93, 0x38, 0x32, 0x3e, 0xbe, 0xa6, 0x5b, 0x99, 0xe0,
	0xba, 0xd1, 0xe8, 0x57, 0x70, 0x27, 0x4d, 0xcd, 0xac, 0x6e, 0x9e, 0xeb, 0xde, 0x8b, 0x23, 0x63,
	0xf7, 0x7a, 0x86, 0x22, 0x7d, 0x83, 0x86, 0xf9, 0xfb, 0x32, 0xd4, 0x95, 0xbb, 0xef, 0x2d, 0x6f,
	0x75, 0x26, 0x94, 0x43, 0x12, 0xbc, 0x20, 0x81, 0xf4, 0x30, 0x2f, 0xbf, 0x02, 0xc1, 0xf2, 0xc9,
	0x14, 0xe6, 0x7e, 0x40, 0xb9, 0x3f, 0x4b, 0x42, 0x81, 0xb5, 0x31, 0xff, 0x45, 0x07, 0x00, 0x01,
	0x19, 0xf9, 0x81, 0x33, 0xbc, 0x9a, 0x8b, 0x5b, 0xa7, 0x91, 0x79, 0xa7, 0xe9, 0x78, 0x21, 0x4e,
	0xfb, 0x5b, 0x8d, 0x38, 0x32, 0x14, 0x3e, 0x56, 0x6c, 0xf4, 0x0b, 0xa8, 0xf2, 0xff, 0xae, 0x23,
	0x7f, 0x2a, 0x8b, 0xf1, 0xca, 0x7d, 0x7e, 0x22, 0x7b, 0xe5, 0x0b, 0xb4, 0x6c, 0xe1, 0xd4, 0xca,
	0xd6, 0xf3, 0xf2, 0xbb, 0xba, 0x8e, 0x2b, 0xdf, 0xf5, 0x3a, 0xe6, 0xa5, 0x0e, 0x8b, 0x5a, 0x5b,
	0xe5, 0x47, 0xcb, 0xaf, 0x63, 0x05, 0x56, 0xaf, 0x63, 0x05, 0x46, 0x17, 0xd0, 0x78, 0x21, 0x82,
	0x90, 0x58, 0x5e, 0xf8, 0x92, 0x04, 0xcd, 0x1a, 0x7f, 0xc1, 0x51, 0xdf, 0xff, 0xb3, 0xa1, 0xaa,
	0x54, 0xde, 0x74, 0x10, 0xc6, 0x03, 0x65, 0x82, 0x15, 0x45, 0xf4, 0x8d, 0xac, 0xe2, 0x0c, 0x59,
	0xd0, 0x89, 0x1f, 0xb8, 0xf4, 0xaa, 0x09, 0x6f, 0x9b, 0xc6, 0x8c, 0x23, 0x63, 0x67, 0x6d, 0x5c,
	0x76, 0xa6, 0x75, 0x5d, 0x34, 0x03, 0x94, 0x82, 0x8e, 0xe3, 0xb2, 0xbf, 0x29, 0xf6, 0xb4, 0x59,
	0xff, 0x76, 0xb3, 0x25, 0xe3, 0xb2, 0xb3, 0x5d, 0x23, 0xbc, 0xbf, 0x00, 0x58, 0x5e, 0x58, 0xa8,
	0x0c, 0xf9, 0xfe, 0x33, 0x3d, 0x87, 0x36, 0xa1, 0xd6, 0xeb, 0x0f, 0xcf, 0x9f, 0xf4, 0x4f, 0x7b,
	0x1d, 0x5d, 0x43, 0xb7, 0x40, 0x3f, 0xec, 0x9d, 0x59, 0x47, 0x87, 0x9d, 0x73, 0x0b, 0x3f, 0x3d,
	0x3d, 0xee, 0xf6, 0x86, 0x7a, 0x1e, 0x21, 0x68, 0x58, 0x47, 0xb8, 0x6b, 0x75, 0xbe, 0x3a, 0xef,
	0x3e, 0x3f, 0x1c, 0x0c, 0x07, 0x7a, 0x81, 0x61, 0x87, 0xbd, 0x61, 0x17, 0xf7, 0xac, 0xa3, 0xf3,
	0x2e, 0xc6, 0x7d, 0xac, 0x17, 0x19, 0xc6, 0xc4, 0xac, 0xd3, 0xe1, 0x41, 0x1f, 0x1f, 0x7e, 0xdd,
	0xed, 0xe8, 0xa5, 0xfd, 0x36, 0x34, 0xb2, 0xff, 0xca, 0xd8, 0x94, 0xed, 0x83, 0x6e, 0xfb, 0xd9,
	0xb9, 0xd5, 0xe9, 0xe8, 0x39, 0xa4, 0xc3, 0x86, 0x68, 0x9e, 0x9e, 0x74, 0xac, 0x61, 0x57, 0xd7,
	0x96, 0x48, 0xa7, 0x7b, 0xd4, 0x1d, 0x76, 0xf5, 0xfc, 0xfe, 0x08, 0x60, 0xf9, 0x3e, 0x84, 0x2a,
	0x50, 0x78, 0xda, 0x1d, 0xea, 0x39, 0x54, 0x87, 0x4a, 0xbb, 0xdf, 0xeb, 0x75, 0xdb, 0x43, 0x5d,
	0x43, 0x00, 0xe5, 0x84, 0x8f, 0xaa, 0x50, 0x3c, 0xe8, 0x5a, 0x1d, 0xbd, 0xc0, 0x28, 0xfd, 0x93,
	0xe1, 0x61, 0xbf, 0x37, 0xd0, 0x8b, 0x0c, 0x3e, 0xe9, 0x0f, 0x86, 0x7a, 0x89, 0x49, 0x9c, 0x9c,
	0x0e, 0xf5, 0x32, 0xaa, 0x41, 0x69, 0x88, 0xad, 0x76, 0x57, 0xaf, 0xec, 0x4f, 0x60, 0x33, 0x93,
	0x98, 0x8c, 0x64, 0xf5, 0xbe, 0xd2, 0x73, 0xa8, 0x04, 0x9a, 0xa5, 0x6b, 0x6c, 0xb8, 0x65, 0x59,
	0x96, 0x9e, 0x67, 0xa3, 0xda, 0x3d, 0xeb, 0xb8, 0xab, 0x17, 0x98, 0x23, 0x8f, 0x9f, 0xeb, 0x45,
	0xf6, 0xec, 0x0d, 0xa4, 0xf2, 0x10, 0xeb, 0x65, 0x66, 0x0c, 0xfa, 0x96, 0x5e, 0xe1, 0x06, 0x3e,
	0xd3, 0xab, 0xcc, 0x18, 0x3e, 0x1f, 0xea, 0xb5, 0x7d, 0x83, 0x97, 0xa3, 0x24, 0x75, 0x39, 0xde,
	0x3e, 0xd1, 0x73, 0xcc, 0x38, 0xed, 0x9c, 0xe8, 0xda, 0xfe, 0x3d, 0xa8, 0xa5, 0x89, 0xc9, 0x97,
	0xe1, 0x5d, 0xe9, 0x39, 0x36, 0xc5, 0xd9, 0xe7, 0xba, 0xc6, 0x9f, 0x3f, 0xd2, 0xf3, 0x8f, 0xff,
	0xa0, 0x41, 0x99, 0xfb, 0x36, 0x44, 0x2d, 0xd8, 0xcc, 0x7c, 0x83, 0x42, 0xef, 0x29, 0x01, 0x74,
	0xe6, 0xbb, 0xce, 0xf6, 0x4e, 0xe6, 0x63, 0xc3, 0xda, 0xe7, 0x2a, 0x33, 0x87, 0xbe, 0x00, 0x78,
	0x4a, 0xa8, 0xf8, 0xa3, 0x1d, 0xae, 0x0b, 0xdc, 0x59, 0xfd, 0x53, 0x26, 0x98, 0x66, 0xee, 0x07,
	0xda, 0xe3, 0x16, 0x54, 0xc4, 0x27, 0x97, 0x90, 0xfd, 0x43, 0x7f, 0x4a, 0xa8, 0xfc, 0x00, 0xa3,
	0xbe, 0xd0, 0x2e, 0x3f, 0xd9, 0x6c, 0x6f, 0xad, 0xc1, 0x66, 0xae, 0xf5, 0xe1, 0xab, 0xff, 0xee,
	0xe4, 0x5e, 0xbd, 0xde, 0xd1, 0xfe, 0xf9, 0x7a, 0x47, 0xfb, 0xcf, 0xeb, 0x1d, 0xed, 0xeb, 0xe5,
	0x07, 0xbd, 0x8b, 0x32, 0xaf, 0x67, 0x3f, 0xfc, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x79, 0xec,
	0x79, 0x62, 0xf2, 0x13, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ChecksClient is the client API for Checks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ChecksClient interface {
	// RegisterProbe causes this probe to be reported as online with
	// worldping-api.
	//
	// The probe is identified via an authentication token provided
	// in a different channel by worldping-api.
	RegisterProbe(ctx context.Context, in *Void, opts ...grpc.CallOption) (*RegisterProbeResult, error)
	// GetChanges returns a list of check operations, specifying
	// whether to add, update or delete checks.
	GetChanges(ctx context.Context, in *Void, opts ...grpc.CallOption) (Checks_GetChangesClient, error)
}

type checksClient struct {
	cc *grpc.ClientConn
}

func NewChecksClient(cc *grpc.ClientConn) ChecksClient {
	return &checksClient{cc}
}

func (c *checksClient) RegisterProbe(ctx context.Context, in *Void, opts ...grpc.CallOption) (*RegisterProbeResult, error) {
	out := new(RegisterProbeResult)
	err := c.cc.Invoke(ctx, "/worldping.Checks/RegisterProbe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *checksClient) GetChanges(ctx context.Context, in *Void, opts ...grpc.CallOption) (Checks_GetChangesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Checks_serviceDesc.Streams[0], "/worldping.Checks/GetChanges", opts...)
	if err != nil {
		return nil, err
	}
	x := &checksGetChangesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Checks_GetChangesClient interface {
	Recv() (*CheckChange, error)
	grpc.ClientStream
}

type checksGetChangesClient struct {
	grpc.ClientStream
}

func (x *checksGetChangesClient) Recv() (*CheckChange, error) {
	m := new(CheckChange)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ChecksServer is the server API for Checks service.
type ChecksServer interface {
	// RegisterProbe causes this probe to be reported as online with
	// worldping-api.
	//
	// The probe is identified via an authentication token provided
	// in a different channel by worldping-api.
	RegisterProbe(context.Context, *Void) (*RegisterProbeResult, error)
	// GetChanges returns a list of check operations, specifying
	// whether to add, update or delete checks.
	GetChanges(*Void, Checks_GetChangesServer) error
}

// UnimplementedChecksServer can be embedded to have forward compatible implementations.
type UnimplementedChecksServer struct {
}

func (*UnimplementedChecksServer) RegisterProbe(ctx context.Context, req *Void) (*RegisterProbeResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterProbe not implemented")
}
func (*UnimplementedChecksServer) GetChanges(req *Void, srv Checks_GetChangesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetChanges not implemented")
}

func RegisterChecksServer(s *grpc.Server, srv ChecksServer) {
	s.RegisterService(&_Checks_serviceDesc, srv)
}

func _Checks_RegisterProbe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChecksServer).RegisterProbe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worldping.Checks/RegisterProbe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChecksServer).RegisterProbe(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Checks_GetChanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Void)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChecksServer).GetChanges(m, &checksGetChangesServer{stream})
}

type Checks_GetChangesServer interface {
	Send(*CheckChange) error
	grpc.ServerStream
}

type checksGetChangesServer struct {
	grpc.ServerStream
}

func (x *checksGetChangesServer) Send(m *CheckChange) error {
	return x.ServerStream.SendMsg(m)
}

var _Checks_serviceDesc = grpc.ServiceDesc{
	ServiceName: "worldping.Checks",
	HandlerType: (*ChecksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterProbe",
			Handler:    _Checks_RegisterProbe_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetChanges",
			Handler:       _Checks_GetChanges_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "checks.proto",
}

// TenantsClient is the client API for Tenants service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TenantsClient interface {
	// GetTenant returns the details of the specified tenant
	GetTenant(ctx context.Context, in *TenantInfo, opts ...grpc.CallOption) (*Tenant, error)
}

type tenantsClient struct {
	cc *grpc.ClientConn
}

func NewTenantsClient(cc *grpc.ClientConn) TenantsClient {
	return &tenantsClient{cc}
}

func (c *tenantsClient) GetTenant(ctx context.Context, in *TenantInfo, opts ...grpc.CallOption) (*Tenant, error) {
	out := new(Tenant)
	err := c.cc.Invoke(ctx, "/worldping.Tenants/GetTenant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TenantsServer is the server API for Tenants service.
type TenantsServer interface {
	// GetTenant returns the details of the specified tenant
	GetTenant(context.Context, *TenantInfo) (*Tenant, error)
}

// UnimplementedTenantsServer can be embedded to have forward compatible implementations.
type UnimplementedTenantsServer struct {
}

func (*UnimplementedTenantsServer) GetTenant(ctx context.Context, req *TenantInfo) (*Tenant, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTenant not implemented")
}

func RegisterTenantsServer(s *grpc.Server, srv TenantsServer) {
	s.RegisterService(&_Tenants_serviceDesc, srv)
}

func _Tenants_GetTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantsServer).GetTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worldping.Tenants/GetTenant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantsServer).GetTenant(ctx, req.(*TenantInfo))
	}
	return interceptor(ctx, in, info, handler)
}

var _Tenants_serviceDesc = grpc.ServiceDesc{
	ServiceName: "worldping.Tenants",
	HandlerType: (*TenantsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTenant",
			Handler:    _Tenants_GetTenant_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "checks.proto",
}

func (m *Void) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Void) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Void) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegisterProbeResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterProbeResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterProbeResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintChecks(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Probe.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintChecks(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Probe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Probe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Probe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChecks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Longitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Longitude))))
		i--
		dAtA[i] = 0x35
	}
	if m.Latitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Latitude))))
		i--
		dAtA[i] = 0x2d
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TenantId != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.TenantId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TenantInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TenantInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TenantInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tenant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tenant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tenant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Modified != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Modified))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.Created != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Created))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.EventsRemote != nil {
		{
			size, err := m.EventsRemote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MetricsRemote != nil {
		{
			size, err := m.MetricsRemote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.OrgId != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.OrgId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoteInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Check.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintChecks(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Operation != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Label) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Label) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Label) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Check) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Check) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Check) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Modified != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Modified))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.Created != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Created))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Probes) > 0 {
		dAtA7 := make([]byte, len(m.Probes)*10)
		var j6 int
		for _, num1 := range m.Probes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintChecks(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x4a
	}
	{
		size, err := m.Settings.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintChecks(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChecks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Timeout != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x28
	}
	if m.Offset != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x20
	}
	if m.Frequency != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Frequency))
		i--
		dAtA[i] = 0x18
	}
	if m.TenantId != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.TenantId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CheckSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Dns != nil {
		{
			size, err := m.Dns.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Http != nil {
		{
			size, err := m.Http.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Ping != nil {
		{
			size, err := m.Ping.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PingSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PingSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PingSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DontFragment {
		i--
		if m.DontFragment {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.PayloadSize != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.PayloadSize))
		i--
		dAtA[i] = 0x20
	}
	if len(m.SourceIpAddress) > 0 {
		i -= len(m.SourceIpAddress)
		copy(dAtA[i:], m.SourceIpAddress)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.SourceIpAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IpVersion != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.IpVersion))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FailIfHeaderNotMatchesRegexp) > 0 {
		for iNdEx := len(m.FailIfHeaderNotMatchesRegexp) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FailIfHeaderNotMatchesRegexp[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChecks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.FailIfHeaderMatchesRegexp) > 0 {
		for iNdEx := len(m.FailIfHeaderMatchesRegexp) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FailIfHeaderMatchesRegexp[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChecks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.FailIfBodyNotMatchesRegexp) > 0 {
		for iNdEx := len(m.FailIfBodyNotMatchesRegexp) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FailIfBodyNotMatchesRegexp[iNdEx])
			copy(dAtA[i:], m.FailIfBodyNotMatchesRegexp[iNdEx])
			i = encodeVarintChecks(dAtA, i, uint64(len(m.FailIfBodyNotMatchesRegexp[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.FailIfBodyMatchesRegexp) > 0 {
		for iNdEx := len(m.FailIfBodyMatchesRegexp) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FailIfBodyMatchesRegexp[iNdEx])
			copy(dAtA[i:], m.FailIfBodyMatchesRegexp[iNdEx])
			i = encodeVarintChecks(dAtA, i, uint64(len(m.FailIfBodyMatchesRegexp[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.ValidHTTPVersions) > 0 {
		for iNdEx := len(m.ValidHTTPVersions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ValidHTTPVersions[iNdEx])
			copy(dAtA[i:], m.ValidHTTPVersions[iNdEx])
			i = encodeVarintChecks(dAtA, i, uint64(len(m.ValidHTTPVersions[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.ValidStatusCodes) > 0 {
		dAtA13 := make([]byte, len(m.ValidStatusCodes)*10)
		var j12 int
		for _, num1 := range m.ValidStatusCodes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintChecks(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x4a
	}
	if m.FailIfNotSSL {
		i--
		if m.FailIfNotSSL {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.FailIfSSL {
		i--
		if m.FailIfSSL {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.NoFollowRedirects {
		i--
		if m.NoFollowRedirects {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.IpVersion != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.IpVersion))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Headers[iNdEx])
			copy(dAtA[i:], m.Headers[iNdEx])
			i = encodeVarintChecks(dAtA, i, uint64(len(m.Headers[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Method != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Method))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeaderMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AllowMissing {
		i--
		if m.AllowMissing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Regexp) > 0 {
		i -= len(m.Regexp)
		copy(dAtA[i:], m.Regexp)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Regexp)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Header) > 0 {
		i -= len(m.Header)
		copy(dAtA[i:], m.Header)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Header)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DNSRRValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSRRValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DNSRRValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FailIfNotMatchesRegexp) > 0 {
		for iNdEx := len(m.FailIfNotMatchesRegexp) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FailIfNotMatchesRegexp[iNdEx])
			copy(dAtA[i:], m.FailIfNotMatchesRegexp[iNdEx])
			i = encodeVarintChecks(dAtA, i, uint64(len(m.FailIfNotMatchesRegexp[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.FailIfMatchesRegexp) > 0 {
		for iNdEx := len(m.FailIfMatchesRegexp) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FailIfMatchesRegexp[iNdEx])
			copy(dAtA[i:], m.FailIfMatchesRegexp[iNdEx])
			i = encodeVarintChecks(dAtA, i, uint64(len(m.FailIfMatchesRegexp[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DnsSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DnsSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DnsSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ValidateAdditional != nil {
		{
			size, err := m.ValidateAdditional.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.ValidateAuthority != nil {
		{
			size, err := m.ValidateAuthority.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ValidateAnswer != nil {
		{
			size, err := m.ValidateAnswer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ValidRCodes) > 0 {
		for iNdEx := len(m.ValidRCodes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ValidRCodes[iNdEx])
			copy(dAtA[i:], m.ValidRCodes[iNdEx])
			i = encodeVarintChecks(dAtA, i, uint64(len(m.ValidRCodes[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.SourceIpAddress) > 0 {
		i -= len(m.SourceIpAddress)
		copy(dAtA[i:], m.SourceIpAddress)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.SourceIpAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if m.IpVersion != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.IpVersion))
		i--
		dAtA[i] = 0x30
	}
	if m.Protocol != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x28
	}
	if m.RecordType != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.RecordType))
		i--
		dAtA[i] = 0x20
	}
	if m.Port != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Server) > 0 {
		i -= len(m.Server)
		copy(dAtA[i:], m.Server)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Server)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintChecks(dAtA []byte, offset int, v uint64) int {
	offset -= sovChecks(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Void) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovChecks(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RegisterProbeResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Probe.Size()
	n += 1 + l + sovChecks(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovChecks(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Probe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovChecks(uint64(m.Id))
	}
	if m.TenantId != 0 {
		n += 1 + sovChecks(uint64(m.TenantId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Latitude != 0 {
		n += 5
	}
	if m.Longitude != 0 {
		n += 5
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TenantInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovChecks(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tenant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovChecks(uint64(m.Id))
	}
	if m.OrgId != 0 {
		n += 1 + sovChecks(uint64(m.OrgId))
	}
	if m.MetricsRemote != nil {
		l = m.MetricsRemote.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.EventsRemote != nil {
		l = m.EventsRemote.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Created != 0 {
		n += 2 + sovChecks(uint64(m.Created))
	}
	if m.Modified != 0 {
		n += 2 + sovChecks(uint64(m.Modified))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoteInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != 0 {
		n += 1 + sovChecks(uint64(m.Operation))
	}
	l = m.Check.Size()
	n += 1 + l + sovChecks(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Label) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Check) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovChecks(uint64(m.Id))
	}
	if m.TenantId != 0 {
		n += 1 + sovChecks(uint64(m.TenantId))
	}
	if m.Frequency != 0 {
		n += 1 + sovChecks(uint64(m.Frequency))
	}
	if m.Offset != 0 {
		n += 1 + sovChecks(uint64(m.Offset))
	}
	if m.Timeout != 0 {
		n += 1 + sovChecks(uint64(m.Timeout))
	}
	if m.Enabled {
		n += 2
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	l = m.Settings.Size()
	n += 1 + l + sovChecks(uint64(l))
	if len(m.Probes) > 0 {
		l = 0
		for _, e := range m.Probes {
			l += sovChecks(uint64(e))
		}
		n += 1 + sovChecks(uint64(l)) + l
	}
	if m.Created != 0 {
		n += 2 + sovChecks(uint64(m.Created))
	}
	if m.Modified != 0 {
		n += 2 + sovChecks(uint64(m.Modified))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ping != nil {
		l = m.Ping.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Dns != nil {
		l = m.Dns.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PingSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.IpVersion != 0 {
		n += 1 + sovChecks(uint64(m.IpVersion))
	}
	l = len(m.SourceIpAddress)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.PayloadSize != 0 {
		n += 1 + sovChecks(uint64(m.PayloadSize))
	}
	if m.DontFragment {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Method != 0 {
		n += 1 + sovChecks(uint64(m.Method))
	}
	if len(m.Headers) > 0 {
		for _, s := range m.Headers {
			l = len(s)
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.IpVersion != 0 {
		n += 1 + sovChecks(uint64(m.IpVersion))
	}
	if m.NoFollowRedirects {
		n += 2
	}
	if m.FailIfSSL {
		n += 2
	}
	if m.FailIfNotSSL {
		n += 2
	}
	if len(m.ValidStatusCodes) > 0 {
		l = 0
		for _, e := range m.ValidStatusCodes {
			l += sovChecks(uint64(e))
		}
		n += 1 + sovChecks(uint64(l)) + l
	}
	if len(m.ValidHTTPVersions) > 0 {
		for _, s := range m.ValidHTTPVersions {
			l = len(s)
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if len(m.FailIfBodyMatchesRegexp) > 0 {
		for _, s := range m.FailIfBodyMatchesRegexp {
			l = len(s)
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if len(m.FailIfBodyNotMatchesRegexp) > 0 {
		for _, s := range m.FailIfBodyNotMatchesRegexp {
			l = len(s)
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if len(m.FailIfHeaderMatchesRegexp) > 0 {
		for _, e := range m.FailIfHeaderMatchesRegexp {
			l = e.Size()
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if len(m.FailIfHeaderNotMatchesRegexp) > 0 {
		for _, e := range m.FailIfHeaderNotMatchesRegexp {
			l = e.Size()
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeaderMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Header)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Regexp)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.AllowMissing {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DNSRRValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FailIfMatchesRegexp) > 0 {
		for _, s := range m.FailIfMatchesRegexp {
			l = len(s)
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if len(m.FailIfNotMatchesRegexp) > 0 {
		for _, s := range m.FailIfNotMatchesRegexp {
			l = len(s)
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DnsSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Server)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovChecks(uint64(m.Port))
	}
	if m.RecordType != 0 {
		n += 1 + sovChecks(uint64(m.RecordType))
	}
	if m.Protocol != 0 {
		n += 1 + sovChecks(uint64(m.Protocol))
	}
	if m.IpVersion != 0 {
		n += 1 + sovChecks(uint64(m.IpVersion))
	}
	l = len(m.SourceIpAddress)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if len(m.ValidRCodes) > 0 {
		for _, s := range m.ValidRCodes {
			l = len(s)
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if m.ValidateAnswer != nil {
		l = m.ValidateAnswer.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.ValidateAuthority != nil {
		l = m.ValidateAuthority.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.ValidateAdditional != nil {
		l = m.ValidateAdditional.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovChecks(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozChecks(x uint64) (n int) {
	return sovChecks(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *CheckSettings) GetValue() interface{} {
	if this.Ping != nil {
		return this.Ping
	}
	if this.Http != nil {
		return this.Http
	}
	if this.Dns != nil {
		return this.Dns
	}
	return nil
}

func (this *CheckSettings) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *PingSettings:
		this.Ping = vt
	case *HttpSettings:
		this.Http = vt
	case *DnsSettings:
		this.Dns = vt
	default:
		return false
	}
	return true
}
func (m *Void) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Void: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Void: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterProbeResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterProbeResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterProbeResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Probe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Probe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Probe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Probe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Probe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			m.TenantId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Latitude = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Longitude = float32(math.Float32frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TenantInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tenant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tenant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tenant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			m.OrgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricsRemote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetricsRemote == nil {
				m.MetricsRemote = &RemoteInfo{}
			}
			if err := m.MetricsRemote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventsRemote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EventsRemote == nil {
				m.EventsRemote = &RemoteInfo{}
			}
			if err := m.EventsRemote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modified", wireType)
			}
			m.Modified = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Modified |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= CheckOperation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Check", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Check.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Label) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Label: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Label: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Check) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Check: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Check: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			m.TenantId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			m.Frequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frequency |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Settings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChecks
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Probes = append(m.Probes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChecks
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChecks
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthChecks
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Probes) == 0 {
					m.Probes = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChecks
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Probes = append(m.Probes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Probes", wireType)
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modified", wireType)
			}
			m.Modified = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Modified |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ping == nil {
				m.Ping = &PingSettings{}
			}
			if err := m.Ping.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Http == nil {
				m.Http = &HttpSettings{}
			}
			if err := m.Http.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dns == nil {
				m.Dns = &DnsSettings{}
			}
			if err := m.Dns.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PingSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpVersion", wireType)
			}
			m.IpVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpVersion |= IpVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
			}
			m.PayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DontFragment", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DontFragment = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= HttpMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpVersion", wireType)
			}
			m.IpVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpVersion |= IpVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoFollowRedirects", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoFollowRedirects = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailIfSSL", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FailIfSSL = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailIfNotSSL", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FailIfNotSSL = bool(v != 0)
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChecks
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ValidStatusCodes = append(m.ValidStatusCodes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChecks
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChecks
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthChecks
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ValidStatusCodes) == 0 {
					m.ValidStatusCodes = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChecks
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ValidStatusCodes = append(m.ValidStatusCodes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidStatusCodes", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidHTTPVersions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidHTTPVersions = append(m.ValidHTTPVersions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailIfBodyMatchesRegexp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailIfBodyMatchesRegexp = append(m.FailIfBodyMatchesRegexp, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailIfBodyNotMatchesRegexp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailIfBodyNotMatchesRegexp = append(m.FailIfBodyNotMatchesRegexp, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailIfHeaderMatchesRegexp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailIfHeaderMatchesRegexp = append(m.FailIfHeaderMatchesRegexp, HeaderMatch{})
			if err := m.FailIfHeaderMatchesRegexp[len(m.FailIfHeaderMatchesRegexp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailIfHeaderNotMatchesRegexp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailIfHeaderNotMatchesRegexp = append(m.FailIfHeaderNotMatchesRegexp, HeaderMatch{})
			if err := m.FailIfHeaderNotMatchesRegexp[len(m.FailIfHeaderNotMatchesRegexp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Header = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regexp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regexp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowMissing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowMissing = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSRRValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSRRValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSRRValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailIfMatchesRegexp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailIfMatchesRegexp = append(m.FailIfMatchesRegexp, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailIfNotMatchesRegexp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailIfNotMatchesRegexp = append(m.FailIfNotMatchesRegexp, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DnsSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DnsSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DnsSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Server = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordType |= DnsRecordType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= DnsProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpVersion", wireType)
			}
			m.IpVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpVersion |= IpVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidRCodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidRCodes = append(m.ValidRCodes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidateAnswer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidateAnswer == nil {
				m.ValidateAnswer = &DNSRRValidator{}
			}
			if err := m.ValidateAnswer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidateAuthority", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidateAuthority == nil {
				m.ValidateAuthority = &DNSRRValidator{}
			}
			if err := m.ValidateAuthority.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidateAdditional", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidateAdditional == nil {
				m.ValidateAdditional = &DNSRRValidator{}
			}
			if err := m.ValidateAdditional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChecks(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthChecks
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupChecks
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthChecks
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthChecks        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChecks          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupChecks = fmt.Errorf("proto: unexpected end of group")
)
